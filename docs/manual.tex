\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{siunitx}
\usepackage{listings}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{framed}
\hypersetup{
    colorlinks=false,
}

\newcommand{\packagename}[1]{\textit{#1}}
\newcommand{\thispackage}{\packagename{dimensional}}
\newcommand{\experimentalpackage}{\packagename{dimensional-dk-experimental}}
\newcommand{\flag}[1]{\textbf{#1}}
\newcommand{\prerelease}{\begin{framed}
The functionality discussed in this section has not yet been released.
\end{framed}}

\lstset{language=haskell,
numberstyle=\footnotesize,
basicstyle=\ttfamily\footnotesize,
showstringspaces=false,
breaklines=true}
\lstMakeShortInline[columns=fixed]`

\title{
	{Writing Physical Computations in Haskell with \thispackage}\\
	{\small{Version 1.1}}
}
\author{BjÃ¶rn Buckwalter and Douglas McClean}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

The \thispackage{} library provides data types for performing arithmetic with physical
quantities. Information about the physical dimensions of each quantity is embedded in
its type. This allows the compiler to statically verify that no dimensional mistakes have
been made in a calculation. It also facilitates conversion between quantities expressed
in different units and provides documentation of the dimension and units of each physical
quantity a program manipulates.

\section{Installation}

The latest version of \thispackage{} can be installed in the usual way, using the following commands:

\begin{lstlisting}[language=bash]
cabal update
cabal install dimensional
\end{lstlisting}

Historical versions and Haddock documentation are available at \url{http://hackage.haskell.org/package/dimensional}.

Since the release of LTS Haskell 4, \thispackage{} has also been available through Stackage. Stackage
distributes curated sets of packages which are known to compile together. For more information see \url{https://www.stackage.org/}.

\section{\thispackage{} in Five Minutes}

It's extremely easy to get started using the \thispackage{} library.

\begin{lstlisting}
{-# LANGUAGE NoImplicitPrelude #-}

module ReadmeExample where

import Numeric.Units.Dimensional.Prelude
import Numeric.Units.Dimensional.NonSI (mile)

leg :: Length Double
leg = 1 *~ mile -- *~ combines a raw number and a unit to form a quantity

speeds :: [Velocity Double]
speeds = [60, 50, 40, 30] *~~ (kilo meter / hour)
  -- *~~ does the same thing for a whole Functor at once
  -- Parentheses are required around unit expressions that are comingled with *~, /~, *~~, or /~~ operations

timeOfJourney :: Time Double
timeOfJourney = sum $ fmap (leg /) speeds
  -- We can use dimensional versions of ordinary functions like / and sum to combine quantities

averageSpeed :: Velocity Double
averageSpeed = _4 * leg / timeOfJourney
  -- _4 is an alias for the dimensionless number 4

wholeSeconds :: Integer
wholeSeconds = ceiling $ timeOfJourney /~ second
  -- /~ lets us recover a raw number from a quantity and a unit in which it should be expressed

main :: IO ()
main = do
         putStrLn $ "Length of journey is: " ++ showIn minute timeOfJourney
         putStrLn $ "Average speed is: " ++ showIn (mile / hour) averageSpeed
         putStrLn $ "If we don't want to be explicit about units, the show instance uses the SI basis: " ++ show averageSpeed
         putStrLn $ "The journey requires " ++ show wholeSeconds ++ " seconds, rounded up to the nearest second."
\end{lstlisting}

\section{Licensing}

The \thispackage{} package is provided under a BSD 3-clause license.

\section{Contributing}

Contributions to \thispackage{} development, in the form of bug reports,
feature requests, or pull requests, are welcome. The source code repository and issue
tracker are both hosted by GitHub at \url{https://github.com/bjornbm/dimensional}.

% TODO Easiest way to contribute: new units.

% TODO Feature requests go into issue tracker?

% TODO Style guide for pull requests? Documentation and/or test requirements?

% TODO Recommended toolset for contributing: stack + git + github? Anything other than stack required for testing? HLint?

\chapter{Dimensional Arithmetic}

\section{Concepts}

Explain quantities, units, `Quantity`s, and `Unit`s.

% TODO This is also probably the place to give a brief intro to what is a dimension, what is the SI, etc? Or should that be it's own chapter?

\section{Creating Quantities}


\section{Arithmetic}

The `Numeric.Units.Dimensional` module exports a number of arithmetic operators with names matching those
exported by the `Prelude`, but with types that are restricted to allow them only to be used in dimensionally-correct
calculations.

\subsection{Addition, Subtraction, and Negation}

The `negate` and `abs` unary functions are straightforward. They are valid for quantities of all dimensions, and preserve the
dimension of their input. They thus each have type `Num a => Quantity d a -> Quantity d a`.

The `+` and `-` binary operators are valid only when the dimensions of the operands match, and,
similarly to `negate` and `abs`, preserve that dimension as the dimension of the result.
They thus have type `Num a => Quantity d a -> Quantity d a -> Quantity d a`.

The `sum` function operates on `Foldable` collections of quantities of uniform dimension, and returns a quantity of
the same dimension. It thus has type `Num a, Foldable f => f (Quantity d a) -> Quantity d a`. We provide a `mean` function
which does the same but requires a `Fractional a` context in place of the `Num a` context.

\subsection{Multiplication}

Multiplication, division, exponentiation, and roots are more complicated for two reasons. First, and unavoidably, the dimensions of their results are computed
from the dimension(s) of their input(s) in a non-trivial way. Second, to avoid excessive namespace pollution, the `Numeric.Units.Dimensional` module provides
one set of such operators which works for both quantities and units. Because the resulting types are daunting they will each be shown in full, explained in prose,
and shown as specialized to apply only to quantities and as specialized to apply only to units.

The multiplication operator `*` has the following type:

\begin{lstlisting}
(*) :: (KnownVariant v1, KnownVariant v2,
        KnownVariant (v1 V.* v2), Num a) => Dimensional v1 d1 a
                                         -> Dimensional v2 d2 a
                                         -> Dimensional (v1 V.* v2) (d1 * d2) a
\end{lstlisting}

Here `v1` and `v2` are the `Variant`s of the input `Dimensional` quantities. A `Variant` is the lifted version of the
following datatype:

\begin{lstlisting}
data Variant = DQuantity
             | DUnit Metricality
\end{lstlisting}

The `V.*` type family from `Numeric.Units.Dimensional.Variants` forms the product of variants. The product of two quantities is a quantity.
The product of two units is a `NonMetric` unit. The product of a unit with a quantity, or vice versa, is not defined. All `Variant`s are
instances of the `KnownVariant` class, but the constraint appears in the context because the implementation requires breaking parametricity and
needs access to an appropriate dictionary in order to do so.

The `d1` and `d2` type variables describe the dimensions of the two input operands. The `*` type family from `Numeric.Units.Dimensional.Dimensions.TypeLevel`
forms the product of two dimensions.

The numerical representation type is named `a`.

We are now equipped to read the full type. It says that, for multiplication, we can take the product of any two dimensional values whose
variants are known and have a product. The numerical representation types must match, and that type must be an instance of `Num`. The result is a dimensional value
whose variant is the product of the inputs' variants, whose dimension is the product of the inputs' dimensions, and whose numerical representation
type is that of the inputs.

Specialized to operate on quantities, the type of multiplication is much less intimidating:

\begin{lstlisting}
(*) :: (Num a) => Quantity d1 a -> Quantity d2 a -> Quantity (d1 * d2) a
\end{lstlisting}

Specialized to operate on units it's only slightly more involved. The `Typeable` contexts arise because they are
required to ensure that an appropriate `KnownVariant` instance will exist. `Typeable` instances exist for all
possible concrete values of `m1` and `m2`, but the context is required for implementation reasons.

\begin{lstlisting}
(*) :: (Typeable m1, Typeable m2, Num a) => Unit m1 d1 a
                                         -> Unit m2 d2 a
                                         -> Unit 'NonMetric (d1 * d2) a
\end{lstlisting}

\subsection{Division}

The division operator `/` has the following type, very similar to that of multiplication:

\begin{lstlisting}
(/) :: (KnownVariant v1, KnownVariant v2,
        KnownVariant (v1 V.* v2),
        Fractional a) => Dimensional v1 d1 a
                      -> Dimensional v2 d2 a
                      -> Dimensional (v1 V.* v2) (d1 / d2) a
\end{lstlisting}

The type variables have the same names and interpretations. Note that the type of the result still mentions the
`V.*` type family for combining `Variant`s and not a `V./` type family. This is because the rules for combining variants
under division are the same as those for multiplication (or, actually, any binary operation), and thus it is not necessary
to introduce an additional type family.

This type says that, for division, we can take the quotient of any two dimensional values whose variants are known and have a product.
The numerical representation types must match, and that type must be an instance of `Fractional`. The result is a dimensional value
whose variant is the product of the inputs' variants, whose dimension is the quotient of the inputs' dimensions, and whose numerical representation
type is that of the inputs.

Specialized to operate on quantities, the type of division is again less intimidating:

\begin{lstlisting}
(/) :: (Fractional a) => Quantity d1 a -> Quantity d2 a -> Quantity (d1 / d2) a
\end{lstlisting}

Similarly for units:

\begin{lstlisting}
(/) :: (Typeable m1, Typeable m2, Fractional a) => Unit m1 d1 a
                                                -> Unit m2 d2 a
                                                -> Unit 'NonMetric (d1 / d2) a
\end{lstlisting}

The `recip` function forms a quantity whose dimension is the reciprocal of the dimension of the input quantity, and thus it has type
`(Fractional a) => Quantity d a -> Quantity (Recip d) a`, where `Recip d` = `DOne / d`. % = `d ^ 'neg1`

\subsection{Exponentiation}

The exponentiation operator `^` has type:

\begin{lstlisting}
(^) :: (Fractional a, KnownTypeInt i,
        KnownVariant v, KnownVariant (Weaken v)) => Dimensional v d a
                                                 -> Proxy i
                                                 -> Dimensional (Weaken v) (d ^ i) a
\end{lstlisting}

The type variable `v` is the `Variant` of the input, which must be an instance of `KnownVariant` as before. Again, the type variable `a` is
the numerical representation type of the input and of the output, which must be an instance of `Fractional`.

The type variable `i` is of kind `TypeInt` from `Numeric.NumType.DK.Integers`. It is a type-level representation of the integer power to which
the input should be raised. The caller indicates this type by providing a `Proxy` to it in the second argument. It must be a `KnownTypeInt` because
again the implementation must break parametricity with respect to this type, namely by obtaining a term-level representation of the same integer.

The `Weaken` type family from `Numeric.Units.Dimensional.Variants` converts quantities to quantities, and converts all units to `NonMetric` units.

This type says that, for exponentiation, we can raise a dimensional value of any known variant and of any dimension to any known integer exponent.
The numerical representation type of the input must be an instance of `Fractional`. The result is a dimensional value whose variant is the weakening
of the input variant, whose dimension is the dimension of the input raised to the specified power, and whose representation type is that of the input.

Specialized to operate on quantities, the type of exponentiation is:

\begin{lstlisting}
(^) :: (Fractional a, KnownTypeInt i) => Quantity d a
                                      -> Proxy i
                                      -> Quantity (d ^ i) a
\end{lstlisting}

Specialized to operate on units it again requires a `Typeable` context and is:

\begin{lstlisting}
(^) :: (Fractional a, KnownTypeInt i, Typeable m) => Unit m d a
                                                  -> Proxy i
                                                  -> Unit 'NonMetric (d ^ i) a
\end{lstlisting}

\subsection{Roots}

Taking square roots, cube roots, and general roots of quantities can be accomplished using the following functions.
The `NRoot` type family from `Numeric.Units.Dimensional.Dimensions` takes the nth root of a dimension, if it exists.
`Sqrt` and `Cbrt` are type synonyms for the square and cube roots, respectively, of a dimension.

\begin{lstlisting}
sqrt  :: Floating a => Quantity d a -> Quantity (Sqrt d) a
cbrt  :: Floating a => Quantity d a -> Quantity (Cbrt d) a
nroot :: (KnownTypeInt n, Floating a) => Proxy n
                                      -> Quantity d a
                                      -> Quantity (NRoot d n) a
\end{lstlisting}

\subsection{Transcendental Functions}

Most of the `Floating` functions (namely `exp`, `log`, `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, and `atanh`)
require dimensionless arguments and produce dimensionless results, and thus the dimensional versions have type `Floating a => Dimensionless a -> Dimensionless a`.
The `**` operator and `logBase` function are similar but have two dimensionless arguments and type `Floating a => Dimensionless a -> Dimensionless a -> Dimensionless a`.





\chapter{Manipulating Units}

Although most dimensional arithmetic involves manipulating quantities, it is sometimes necessary
to manipulate units themselves. It's possible to combine units by multiplying or dividing them, or to
form new units from existing ones by applying metric prefixes.

A unit of dimension `d` is represented by a value of type `Unit m d a`. Because only certain units can
accept metric prefixes, the type parameter `m` tracks the `Metricality` of the unit. As with quantities,
the final type parameter is the representation type, for units this is the value of the conversion factor
from the unit to its dimension's coherent SI unit.

\section{Unit Arithmetic}

The `*` operator from `Numeric.Units.Dimensional` not only forms the product of two quantities, it can also
form the product of two units. Similarly, the `/` and `^` operators works on units as well as on quantities.
Narrowing the types to look only at how they operates on units:

\begin{lstlisting}
(*) :: (Num a) => Unit m1 d1 a -> Unit m2 d2 a -> Unit 'NonMetric (d1 * d2) a
(/) :: (Fractional a) => Unit m1 d1 a -> Unit m2 d2 a
                      -> Unit 'NonMetric (d1 * d2) a
(^) :: (Fractional a, KnownTypeInt i) => Unit m d a -> Proxy i
                                      -> Unit 'NonMetric (d ^ i)
\end{lstlisting}

As one would expect, the dimension of a product or quotient is the product or quotient of the dimensions of the operands.
Raising a unit to an integer power raises the dimension to the same power, which requires a `Fractional` context as the
power may be negative.

Each metric prefix defined by the SI is provided as a function with the same name as the prefix in the `Numeric.Units.Dimensional.SIUnits` module.
The prefixes which define multiples of a unit, such as kilo and giga, have type `Num a => Unit 'Metric d a -> Unit 'NonMetric d a`.
Those which define submultiples of a unit, such as micro and atto, require a `Fractional` context instead.

A `Unit` in one representation type may be converted to another using the same functions as are provided for quantities.
Again narrowing the types to look only at how they operates on units:

\begin{lstlisting}
changeRep :: (Real a, Fractional b)  => Unit m d a       -> Unit m d b
changeRepApproximate :: (Floating b) => Unit m d ExactPi -> Unit m d b
\end{lstlisting}

It's also possible to form the exact version of a `Unit` using:

\begin{lstlisting}
exactify :: Unit m d a -> Unit m d ExactPi
\end{lstlisting}

Moving back and forth between `Metric` and `NonMetric` units can be accomplished when needed using:

\begin{lstlisting}
weaken     :: Unit m d a -> Unit 'NonMetric d a
strengthen :: Unit m d a -> Maybe (Unit 'Metric d a)
\end{lstlisting}

Taken together, these operators and functions are quite flexible in allowing new units to be formed from
the combination of existing units. Support for creating new units will be discussed in \ref{constructing-new-units} after
the concept of unit names has been introduced.

\section{Unit Names}

\subsection{Interchange Names}
\subsection{Unit Name Normal Forms}

\section{Constructing New Units} \label{constructing-new-units}

New units may be constructed using one of three functions, depending on whether the required conversion factor to the coherent
SI unit of the same dimension is an integer, a rational number, or involves the mention of $ \pi $.

\begin{lstlisting}
mkUnitZ :: Num a        => UnitName m -> Integer  -> Unit m1 d a -> Unit m d a
mkUnitQ :: Fractional a => UnitName m -> Rational -> Unit m1 d a -> Unit m d a
mkUnitR :: Floating a   => UnitName m -> ExactPi  -> Unit m1 d a -> Unit m d a
\end{lstlisting}

Regardless of the type of the conversion factor, it must not be zero. This is because it would not be possible
to express any quantities in a unit if that unit's conversion factor were zero. Negative conversion factors are accepted
and handled properly, but their use is strongly discouraged as it is likely to be confusing.

Taking an example (already provided in the `Numeric.Units.Dimensional.NonSI` module), one might define:

\begin{lstlisting}
usGallon, usQuart :: (Fractional a) => Unit 'NonMetric DVolume a
usGallon = mkUnitQ (ucum "[gal_us]" "gal" "gallon") 231             (cubic inch)
usQuart  = mkUnitQ (ucum "[qt_us]"  "qt"  "quart")  (1 Prelude./ 4) usGallon
\end{lstlisting}

Each requires as arguments the name of the unit to be formed, the scale factor relating it to a unit which has already been defined,
and that unit. In addition to the constraints verified by the type system, these functions further check that the supplied scale factor is
strictly positive, and that when combined with the scale factor in the defining unit the scale factor of the resulting defined unit remains
within the appropriate class of values.

Note in the example that even though the `usGallon` is defined to be an integer multiple of its defining unit, the `cubic inch`, it is nevertheless
necessary to use `mkUnitQ` instead of `mkUnitR`. This is because the `cubic inch` is not an integer multiple of the SI coherent unit of volume, the cubic meter.

Users should feel free to submit pull requests to \thispackage{} for any units that are useful to their work which are not included.




\chapter{Dimensional Vectors}

\prerelease{}

It's frequently convenient to manipulate vectors of dimensional values. Because such vectors often have heterogenous
dimensions, existing Haskell vector libraries are a poor solution. In order to retain dimensional typing in these situations,
\thispackage{} offers a standard representation for dimensional vectors, however it does not include a full-featured system for
dimensional linear algebra. A package using \thispackage{} and \packagename{hmatrix} to do so is under early-stage development.





\chapter{Dynamic Dimensions}

Statically tracked dimensions are wonderful and vastly simplify development of code that works with quantities of specific
dimensions. However there are times when we might wish to manipulate quantities or units of unknown dimensions. This can be
especially useful when parsing user input.

The `Numeric.Units.Dimensional.Dynamic` module provides a number of features for manipulating quantities or units with dimensions that are only
known dynamically.

\section{Dimensions}

Just like the `Dimension` kind provides a type-level representation of dimensions, the `Dimension'` type from `Numeric.Units.Dimensional.Dimensions`
provides a term-level representation of dimensions.

You can access the term-level dimension of almost anything (like a `Quantity`, `Unit`, or \\
`AnyQuantity`) using the `dimension` function from the `HasDimension` class. For things
which may or may not have a dimension (like a `DynQuantity`), there's also the `dynamicDimension`
function from the `HasDynamicDimension` class.

Arithmetic on term-level dimensions can be performed using the `*`, `/`, `^`, `recip`, and `nroot` functions from `Numeric.Units.Dimensional.Dimensions.TermLevel`.

The dimension of dimensionless values is `dOne`, and `Dimension'` values form a `Monoid` under multiplication.

\section{Dynamic Quantities} \label{dynamic-quantities}

The `AnyQuantity` type represents a quantity whose dimension is only known dynamically. One use of this
type, for example, is to read dimensional values from a configuration file. In a context where
`parseQuantity :: Text -> AnyQuantity Scientific` one might write:

\begin{lstlisting}
readMaximumSpeed :: Text -> Maybe (Velocity Double)
readMaximumSpeed config = fmap changeRep . promoteQuantity . parseQuantity
\end{lstlisting}

Quantities can be demoted to dynamic quantities, and dynamic quantities can be promoted back into quantities,
using the functions below:

\begin{lstlisting}
demoteQuantity  :: (Demotable q, Promotable d) => q a -> d a
promoteQuantity :: (Demotable q, Promotable d) => d a -> Maybe (q a)
\end{lstlisting}

The type classes `Demotable` and `Promotable` are provided because, in addition to `AnyQuantity`, there is also a more general type, `DynQuantity`. The `Demotable` class includes both `Quantity d` and `AnyQuantity`, while the `Promotable` class includes both `AnyQuantity` and `DynQuantity`.
While an `AnyQuantity a` value definitely represents a `Quantity` of some dimension, a `DynQuantity a` value may not.
This is a useful property because it admits complete and well-behaved `Num`, `Fractional`, and `Floating` instances for `DynQuantity`. This allows
arithmetic to be performed with dynamic quantities which is nonetheless dimensionally verified at runtime. For example,
the result of `demoteQuantity (3 *~ meter) + demoteQuantity (47 *~ second)` cannot be successfully promoted to an
`AnyQuantity`, or to a `Quantity` of any dimension.

\section{Dynamic Units}

It is also occasionally convenient to manipulate units with unknown dimensions. The `AnyUnit` type provides
an analogue of `AnyQuantity` for `Unit`s.

Similar promotion and demotion functions are available:

\begin{lstlisting}
demoteUnit  :: (KnownDimension d) => Unit m d a -> AnyUnit
promoteUnit :: (KnownDimension d) => AnyUnit
                                  -> Maybe (Unit 'NonMetric d ExactPi)
\end{lstlisting}

Because all `Unit m d a` values carry their conversion factor represented as an `ExactPi` value alongside their value in
the type `a`, it's not necessary for `AnyUnit` to carry a type parameter. When promoting an `AnyUnit` we always represent
the result using `ExactPi`, if you desire a different representation you can use `changeRepApproximate` to obtain one.
Similarly, while the result of promotion is always tagged as `NonMetric`, you can use `strengthen` to attempt to convert
it to a `Metric` unit.

Arithmetic operations `*`, `/`, `^`, and `recip` are provided for manipulating `AnyUnit`s. There is no need for an analogue
of `DynQuantity` for these operations, because they are all total. An `applyPrefix :: Prefix -> AnyUnit -> Maybe AnyUnit`
function is available for dynamically applying metric prefixes to units, it will return `Nothing` if the unit was not `Metric`.

Dynamic analogues of `*~` and `/~` allow the use of dynamic units to convert between raw values and dynamic quantities, as:

\begin{lstlisting}
(*~) :: (Floating a, Promotable q) =>   a -> AnyUnit -> q a
(/~) :: (Floating a, Promotable q) => q a -> AnyUnit -> Maybe a
\end{lstlisting}

Note that `/~` will return `Nothing` if the dimensions of the supplied dynamic quantity do not match those of the
dynamic unit. The `Floating` context is required for both operations because the conversion factor of the
dynamic unit may involve $ \pi $.



\chapter{Fixed Point Dimensional Arithmetic}

\prerelease{}

Although floating point arithmetic is fast and convenient for many applications, the \thispackage{} package also provides
support for performing fixed point computations with dimensional values.

Using the \packagename{exact-pi} package's support for type-level positive rationals extended with an exact representation
of $ \pi $, \thispackage{} statically encodes the scale factor between the least significant bit of the chosen `Integral`
representation and the coherent SI unit of the quantity's dimension. This allows fixed point representations to be
treated uniformly and correctly by arithmetic operations without requiring the programmer to appropriately scale the results
before storing them.

\section{Describing Fixed-Point Quantity Types}

The familiar `Quantity` type is an alias for `SQuantity One` (where `One`) is the \packagename{exact-pi}
package's representation of the number $ 1 $. While it is possible to use `SQuantity` with other scaling factors and a
floating point or exact rational representation type, it is rarely necessary to do so because the range of common floating
point representations can comfortably encode both very large and very small physical quantities directly represented in the
coherent SI unit of their dimension.

Where `SQuantity` becomes more directly useful, and where special fixed point support is required, is when an
`Integral` representation type is desired. For example, an embedded system may wish to encode the estimated
velocity of a vehicle as a 16-bit signed integer with a minimum increment of \SI{1}{\centi\meter\per\second}. It is common
to represent such a value by a variable of type `Int16` and an accompanying comment or naming convention indicating
the dimension and scale factor, but \thispackage{} provides a more expressive type, which can be written in one of several ways.

\subsection{Without Template Haskell}

Without using Template Haskell, one could write:

\begin{lstlisting}
import Numeric.Units.Dimensional.FixedPoint.Prelude
import qualified Data.ExactPi.TypeLevel as E
import Data.Int

type VehicleSpeed = SQuantity (E.One E./ (E.ExactNatural 100)) DLength Int16
\end{lstlisting}

\subsection{With Template Haskell} \label{fixed-point-th}

With Template Haskell and the \packagename{dimensional-th} package, either of the following simpler forms is equivalent to the one given above:

\begin{lstlisting}
import Numeric.Units.Dimensional.FixedPoint.Prelude
import Numeric.Units.Dimensional.TH
import Data.Int
import qualified Prelude as P

type VehicleSpeed1 = SQuantity $(exactPiType $ 1 P./ 100) DLength Int16
type VehicleSpeed2 = [fixed| cm / s |] Int16
\end{lstlisting}

In the latter example, note that both the scale factor and dimension were determined by the type quasiquoter, and so it
only remained to specify the representation type.

TODO: give an example where the scale isn't an exact unit, other examples of accepted syntax for quasiquoter

\section{Fixed-Point Arithmetic}

TODO: give examples of performing arithmetic with such values

\subsection{Constructing Fixed-Point Values}

In addition to fixed-point analogues of the `*~` and `/~` operators, the `Numeric.Units.Dimensional.FixedPoint`
module also provides access to the least positive representable value in any fixed-point quantity type `epsilon :: (Integral a) => SQuantity s d a`.

By importing the `Numeric.Units.Dimensional.Coercion` function, users can also gain access to the `Quantity` newtype constructor
and the ability to `coerce` between raw values and quantities, including fixed-point quantities.

\subsection{Transcendental Functions}

The transcendental functions from `Numeric.Units.Dimensional` have types like:

\begin{lstlisting}
sin :: Floating a => Dimensionless a -> Dimensionless a
\end{lstlisting}

However when using fixed point values, we wish to use representation types which lack `Floating` instances. Accordingly,
the `Numeric.Units.Dimensional.FixedPoint` module provides transcendental functions with types like the one given below.
Note that as is often the case in the fixed point module, in order to provide maximal flexibility and preserve precision of
intermediate results, the result type of the operation is not fully determined by the type of its operand and instead is
determined from context.

\begin{lstlisting}
sin :: (KnownExactPi s1, KnownExactPi s2 Integral a) => SQuantity s1 DOne a -> SQuantity s2 DOne a
\end{lstlisting}

\section{Common Fixed-Point Types}

Also provided are aliases for some commonly used fixed-point types. `Q n a` represents a dimensionless value stored with `n` fractional bits
and a representation of type `a`. For example, `Q 15 Int16` is the type of values with $ 1 $ sign bit, no integer bits, and $ 15 $ fractional bits.
Similarly, `Q 12 Natural` is the type of values with no sign bit, as many integer bits as needed, and $ 12 $ fractional bits.

Fixed-point single turn angles can be convenient because hardware-supported modular addition and subtraction can be used to maintain the
single turn invariant. Signed versions of such types, representing angles in the interval $ [-\pi, \pi) $, are available as `Angle8`, `Angle16`,
and `Angle32`.




\chapter{Interoperating with Other Packages}

\section{Other Packages in the \thispackage{} Ecosystem}

\subsection{\packagename{dimensional-codata} for CODATA Values of Physical Constants}

The Committee on Data for Science and Technology (CODATA) publishes periodic reports on the best available
experimental values for a wide variety of physical constants. The \packagename{dimensional-codata} package
provides some of the more commonly used ones with dimensional types.

Contributions are welcome if users require constants supplied by CODATA which are not included in the library.

\subsection{\packagename{dimensional-parsers} for Parsing Units and Quantities}

The \packagename{dimensional-parsers} package provides parsers (both as parser combinators and as functions from `String` to
dynamic quantities \ref{dynamic-quantities} and dynamic units \ref{dynamic-units}.


\subsection{\packagename{dimensional-th} Template Haskell Conveniences for \thispackage{}}

The \packagename{dimensional-th} package provides Template Haskell splices and quasi-quotations for use alongside \thispackage{}.

These features are especially useful when working with fixed-point quantities, which can otherwise involve burdensome manual encoding
of scaling factors as type-level numbers. See \ref{fixed-point-th} for notes on this use case.


\section{Popular General-Purpose Packages}

\subsection{\packagename{ad} for Automatic Differentiation}

\prerelease{}

\subsection{\packagename{aeson} for JSON Serialization}

Users of the \packagename{aeson} package can find `ToJSON`
and `FromJson` instances for `Quantity` and for certain ancillary types by
enabling the \flag{aeson} flag when installing \thispackage{}.

\subsection{\packagename{attoparsec} for Unit and Quantity Parsing}

Support for \packagename{attoparsec} is provided through the \packagename{parsers} package, see \ref{parsers-support}.

\subsection{\packagename{binary} for Binary Serialization}

Users of the \packagename{binary} package can find `Binary`
instances for `Quantity` and for certain ancillary types by
enabling the \flag{binary} flag when installing \thispackage{}.

\subsection{\packagename{cereal} for Binary Serialization}

Users of the \packagename{cereal} package can find `Serialize`
instances for `Quantity` and for certain ancillary types by
enabling the \flag{cereal} flag when installing \thispackage{}.

\subsection{\packagename{HaTeX} for \LaTeX{} Generation}

\prerelease{}

\subsection{\packagename{ihaskell} for Interactive Notebooks}

\prerelease{}

The IHaskell project provides support for interactive notebook documents containing
Haskell code through the Jupyter project.

Instances of `IHaskellDisplay` for `Quantity` and `Unit`
allow attractive \LaTeX{}-style display of dimensional values in your notebooks. These
instances can be found in the \\
`Numeric.Units.Dimensional.IHaskell` module of the \experimentalpackage{}
package.

\subsection{\packagename{lens}}

Todo: Without taking a dependency on lens, offer a declaration that can convert a unit into a lens from quantities to numeric values.
Explain here how to use that facility.

\subsection{\packagename{parsec} for Unit and Quantity Parsing}

Support for \packagename{parsec} is provided through the \packagename{parsers} package, see \ref{parsers-support}.

\subsection{\packagename{parsers} for Unit and Quantity Parsing} \label{parsers-support}

\prerelease{}

Users of the \packagename{parsers} package can find parsers recognizing
unit names (both in natural language and in the UCUM interchange format) and
quantities in the \packagename{dimensional-parsers} package.

These parsers are also used by the \packagename{dimensional-th} package to provide
Template Haskell quasi-quotations for quantities and for fixed-point types, as
discussed in \ref{fixed-point-th}.

\subsection{\packagename{time} for Times and Dates}

Users of the \packagename{time} package can find functions and lenses for converting
between the `DiffTime` representation and \thispackage{}'s `Time` representation in the
`Numeric.Units.Dimensional.Time` module of the \experimentalpackage{} package.

\subsection{\packagename{vector} for Boxed and Unboxed Arrays}

The \thispackage{} package provides instances of the `Vector` and `MVector` data families and the `Unbox` class
allowing `Quantity`s to be stored in unboxed vectors for improved performance and reduced storage overhead.

\subsection{\packagename{vector-space} for Linear Algebra}

Users of the \packagename{vector-space} package can find appropriate instances of the `AdditiveGroup` and \\
`VectorSpace` classes, along with an instance of `InnerSpace` for dimensionless quantities, by enabling the \flag{vector-space}
package flag when installing \thispackage{}.

\chapter{Libraries Using \thispackage}

\section{\packagename{atmos} for Modeling Earth's Atmosphere}

The \packagename{atmos} package provides a dimensionally-typed implementation of the 1976 International Standard
Atmosphere, a model of how pressure, temperature, the speed of sound, and related quantities vary with
altitude in the Earth's atmosphere.

\section{\packagename{igrf} for Modeling Earth's Magnetic Field}

\prerelease{}

The \packagename{igrf} package provides a dimensionally-typed implementation of the International Geomagnetic
Reference Field, including parsing of model text files in the format released by the International Association of
Geomagnetism and Aeronomy and the United States National Oceanographic and Atmospheric Administration. The
package also directly includes the model coefficients for the most recent model releases.

\chapter{Included Dimensions and Units}

\chapter{Comparison with Other Libraries}

\section{quantities}
\section{units}
\section{uom-plugin}
\section{unittyped}
\section{caldims}

\end{document}

